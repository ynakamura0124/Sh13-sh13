// BRIKENGammaSourceGeneratorAction.cpp generated by R. Yokoyama on 1/29/2020

#include "BRIKENGammaSourceGeneratorAction.hh"

using namespace CLHEP;

BRIKENGammaSourceGeneratorAction::BRIKENGammaSourceGeneratorAction():rand3(0)
{
}

BRIKENGammaSourceGeneratorAction::~BRIKENGammaSourceGeneratorAction() {
}

bool BRIKENGammaSourceGeneratorAction::Next() {
	/* reads the next entry of the tree */
	/* if the file ends, restart from the first entry */
	//auto read_next = [&]()->bool { gROOT->ProcessLine("param->SetVal(reader->Next());"); return ret_val_->GetVal(); };
	auto read_next = [&]()->bool { return tree_reader_->Next();};
	if (!read_next()) {
		gROOT->ProcessLine("reader->Restart();");
		if (!read_next()) {
			std::cout << "[BRIKENGammaSourceGeneratorAction]: failed to read events from tree." << std::endl;
			return false;
		}
	}
	return true;
}

void BRIKENGammaSourceGeneratorAction::SetReader() {
	std::cout << "[BRIKENGammaSourceGeneratorAction]: SetReader() called." << std::endl;
	//reader_value_ = new TTreeReaderValue<impData2TTree>(*tree_reader_,branch_name_.c_str());
	std::cout << "[BRIKENGammaSourceGeneratorAction]: reader_value_ created" << std::endl;
	return;
}

const G4ThreeVector BRIKENGammaSourceGeneratorAction::ReadPosition() {

	impData2TTree* data = nullptr;
	Int_t last_layer = -1;
	Bool_t invalid = true;
	do {
		if (!Next())
			return default_pos_;
		data = reader_value_->Get();

		while (data->z == 0 && data->x == 0 && data->y == 0) {
			Next();
			data = reader_value_->Get();
		}

		/* finds the deepest layer hit in the event */
		auto &imp_vec = data->vectorOfImp;
		last_layer = -1;
		for (const auto& imp : imp_vec) {
			if (last_layer < imp.Z)
				last_layer = imp.Z;
		}
		if (pid_gate_ && (!IsInside(data->aoq, data->zet)))
			invalid = true;
		else
			invalid = false;

	} while (invalid || last_layer > data->z);
	// if Z is smaller than last layer, that means the ion didn't
	// stop at this layer so skip.
	
	G4double pos_x = 0.0;
	G4double pos_y = 0.0;
	G4double pos_z = 0.0;

	if (data->z == 4) { // YSO
		pos_x = GetYSOPosZ();
		pos_x = pos_x + (rand3.Rndm() - 0.5)*GetYSOThickness();
		pos_z = GetYSOPosXY(data->x);
		pos_y = GetYSOPosXY(data->y);
	}
	else { // WAS3ABi
		pos_x = GetWAS3ABiPosZVec().at(data->z);
		pos_x = pos_x + (rand3.Rndm() - 0.5)*GetWAS3ABiThickness();
		const auto cont = [&](const int& x)->double {return (double)x + rand3.Rndm(); };
		pos_z = GetWAS3ABiPosXY(cont(data->x));
		pos_y = GetWAS3ABiPosXY(cont(data->y));
	}
	std::cout << " (" << data->z << ", " << pos_x << "), (" << data->y << ", " << pos_y << "), (" << data->x << ", " << pos_z << ")";
	std::cout << "\tZ:AoQ = " << data->zet << ":" << data->aoq << std::endl;

	return G4ThreeVector(pos_x,pos_y,pos_z);
}
